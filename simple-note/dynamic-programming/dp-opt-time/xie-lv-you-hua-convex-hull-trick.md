# 斜率優化 \(Convex Hull Trick\)

前面的都是比較簡單一點的DP優化，從這裡開始會變得稍微難一點。

## 介紹

斜率優化應該不算太難的 DP 優化，而且出現的頻率也絕對不在少數。

雖然說他的名字叫做斜率優化，但是我個人覺得凸包優化 \(英文名字\) 比較適合他。理由的話我們就繼續看下去吧。

## 概述

### 理論

有一些 1D/1D 的 DP 的轉移式會長成下面這樣：

$$dp(i)=h(i)+\max\limits_{j\leq r(i)}\{A(j)X(i)+B(j)\}$$

其中 $$r(i)<i$$是一個遞增函數、$$X(i)$$和 $$h(i)$$是容易求得的函數，而 $$A(j)$$、$$B(j)$$裡面可能會包含 $$dp(j)$$，也就是 $$j$$是狀態 $$i$$ 的子問題。這樣子的複雜度是 $$O(N^2)$$的，而斜率優化就是在優化這種類型的轉移式。因為 $$h(i)$$是一個容易求得的函數，而真正難算的部分在於後面的 $$max$$，所以下面說明後面那坨東西要怎麼優化。

最一開始有提到，DP 優化大多都是優化轉移的過程，斜率優化也不例外，就是要加速轉移的過程。為了加速轉移的過程，我們可以拋棄掉那些不可能成為轉移來源的狀態不去處理，那要怎麼做呢？

對於每個**已經算出答案的** $$j$$\(也就是說 $$A(j)$$和 $$B(j)$$都已經被算出來了\)，我們畫一條直線 $$y=A(j)x+B(j)$$到平面上。那麼結果可能會長得跟下面這張圖這樣 \(考慮 $$j\in[0,4]$$\)：

\(圖片待補\)

我們會發現所有數字的最大值會形成一個**下凸包**。而如果有線完全落在這個下凸包的下面\(例如 $$j=3$$那條線\)，那麼這條線就永遠不可能會成為我們的轉移來源。換句話說，我們的轉移來源只會出現在那個下凸包上面。假設我們現在要更新 $$dp(i)$$這個狀態，我們的轉移就相當於是在這個下凸包上找到 $$X(i)$$這個點是落在下凸包哪一條線段上。把 $$X(i)$$帶入那個線段所得到的值就會是我們的 $$dp(i)$$。

所以說我們現在把題目變成要做兩件事：

1. 動態維護下凸包
2. 快速找到 $$X(i)$$這個點是落在哪一個線段上，並求他的值

### ~~動態凸包?~~

我們現在要維護一個支持**插入操作**跟**查詢操作**的凸包。事實上真的有動態凸包這個東西。但是身為一個佛系競程玩家，我不想學那種又長又不好寫常數又大的東西。所以我們這邊要使用一個神奇的資料結構：李超線段樹

### 李超線段樹

這個東西其實應該被放在資料結構裡面，但是因為 iceylemon 很懶，所以他把決定先寫在這邊。

我們用一個問題來引入李超線段樹這個東西：

> 現在要進行若干次操作，每一次操作會是下列兩種中的一種：
>
> * 插入一條直線
> * 詢問一條直線 $$x=t$$與其他直線相交的點中，最大的 $$y$$ 座標

沒錯，這就是一個動態凸包問題 \(就是我們要解決的問題\)。而李超線段樹就是一個用來解決這類問題的**線段樹變形**。

李超線段樹的理念如下：對**值域**開線段樹。而每個節點維護的是讓這個區間**中點**的值最大的那**一條直線**。注意，每一個節點只維護一條直線。這看起來像是一個奇怪的定義，別急，我們繼續看下去。

考慮 $$[L,R]$$ 這個區間\(線段樹節點\)，不妨先假設原先這個節點維護的是 $$B$$這條直線，而我們現在要**插入**$$A$$這條直線 \(不妨先考慮$$A$$的斜率大於$$B$$\)。那麼應該會有兩種情況，$$A$$帶入$$mid$$ 比較大 \(如下圖\)，或是$$B$$帶入$$mid$$ 比較大。

![](../../../.gitbook/assets/tu-pian-1%20%281%29.png)

上圖顯示 $$A$$ 帶入 $$mid$$ 的值比較大。根據李超線段樹的定義，$$[L,R]$$ 這個節點應該要保留$$A$$這條直線，但是我們會發現$$B$$直線仍然是有可能會被選到的，不能直接把他丟掉。我們看著上面這張圖可以發現，$$B$$這條直線接下來只有可能會在$$mid$$的左邊會被選到。還記得李超線段樹是線段樹吧?我們可以直接往左邊遞迴下去做就可以處理到$$B$$直線的情形了。同理如果 $$B$$ 帶入的 $$mid$$ 值比較大，我們也可以用類似的方法處理。

詳細細節我們可以看下面的程式碼：

李超線段樹插入程式碼

```cpp
struct Line {
    int m, k;
    int val(int x) {
        return m * x + k;
    }
} seg[maxn * 4]; 
// seg 李超線段樹用到的陣列

void insert(Line line, int l, int r, int idx) {
    // line = 要插入的直線
    // 目前處理的區間 [l,r]
    // 對應到線段樹哪一個編號的節點
    if(l == r) {
        // 如果 line 的值到底了還比原本的大，那就直接取代掉
        if(line.val(l) > seg[idx].val(l)) {
            seg[idx] = line;
            return;
        }
    }
    int mid = (l + r) >> 1;
    // 預設要插入的直線斜率比較大
    if(seg[idx].m > line.m) swap(seg[idx], line);
    // 看要往哪邊遞迴
    if(seg[idx].val(mid) < line.val(mid)) {
        swap(line, seg[idx]);
        // 這邊使用 swap 是因為上面有可能 swap 過了
        // 我們不知道現在手上拿的是誰，反正比較弱的就丟下去就對了
        insert(line, l, md, idx << 1);
    }
    else insert(line, md + 1, r, idx << 1 | 1);
}
```

那麼查詢呢？你可能會想要直接查詢最下面那個節點的直線帶進去的值，但很不幸的那是錯的。

回憶一下上面的過程，你可能會發現我們在處理區間的時候只有一直往下處理 $$mid$$值比較小的那條直線可能會被選到的區間。也就是說另外半邊的區間我們是沒有處理的。所以說查詢的過程應該是要由上往下經過的每一個節點都把$$x$$帶進那條直線並取所有值的 $$max$$才是對的。

李超線段樹詢問

```cpp
int query(int x, int l, int r, int idx) {
    // x 是要查詢的點
    if(l == r) return seg[idx].val(x);
    int mid = (l + r) >> 1, ret = seg[idx].val(x);
    if(x <= mid) ret = max(ret, query(x, l, mid, idx << 1));
    else ret = max(ret, query(x, mid + 1, r, idx << 1 | 1);
    return ret;
}
```

我們可以發現全部的操作都跟線段樹一樣，所以總複雜度是 $$O(NlogN)$$

於是我們就可以使用李超線段樹解決上面的問題了。至此斜率優化就這樣被解決了。

## 特例

雖然我們已經把斜率優化解決掉了，但是斜率優化還有一些很有趣的特例。

上面的那個作法是最通用的作法，而如果題目有給定一些特別的性質的話，會有一些更好的做法。

### 斜率單調

如同這一小節的標題，如果我們的斜率單調遞增\(也就是 $$a(i)$$會隨著 $$i$$變大而增加\)，那麼會有一個不用寫線段樹的做法。

由於下凸包這個東西如果 $$x$$座標越大，那麼斜率就會越大。如果我們插入的直線斜率是遞增的話，這不就代表說這條直線只會差在這個下凸包的最右邊嗎？也就是說我們可以直接用一個單調 Stack 來維護我們的凸包。

至於查詢的部分，一個最暴力的作法當然是遍歷整個 Stack，找到 $$X(i)$$在哪一個區間。但是因為區間這個東西是單調遞增的，所以其實我們可以直接對他做二分搜。至此我們獲得了一個 $$O(NlogN)$$但常數比較小的辦法了。

但老實說，我認為如果題目沒有特別卡的話，寫線段樹也不失為一個不錯的選擇，畢竟寫線段樹就不太需要思考 \(x。\(我好像有點毒?\)

### 查詢單調

上面那個做法只是常數比較小而已，那如果我現在再加入查詢單調這件事會變成怎樣呢？

上面的作法需要使用二分搜來進行查詢，而既然現在給定查詢遞增，就代表我們查詢的區間的 $$x$$ 座標只會增加不會減少。也就是說我的查詢只會把值域遍歷一遍而已。所以查詢的複雜度也會是 $$O(N)$$。於是總複雜度就是 $$O(N)$$。

有沒有發現這個做法好像似曾相似？其實**單調隊列優化**就是斜率優化的特例喔！

## 例題

下面這題是一道過於經典的題目，建議大家先不要看題解自己先做。

### APIO 2010 Commando

[題目連結](https://tioj.ck.tp.edu.tw/problems/1745)

給你一個長度為 $$N$$的正整數列 $$x_1,...x_n$$以及一個二次方程 $$f(x)=ax^2+bx+c\ (a < 0)$$。你可以將這個數列分成連續的很多塊，而該分法的價值就是每塊的總和帶入 $$f$$之後的函數值的總和。求可以獲得的最大價值為何。

#### 題解

容易知道轉移式是 $$dp(i)=\max\limits_{j<i}\{dp(j)+f(\sum\limits_{k=j+1}^{i}x_k)\}$$，令 $$S(i)$$代表 $$\sum\limits_{j=1}^{i}x_j$$。那麼就可以變成：

$$dp(i)=\max\limits_{j<i}\{dp(j)+f(S(i) - S(j))\}\\ \ \ \ \ \ \ \ \ \ \ = \max\limits_{j<i}\{dp(j)+a(S(i)^2-2S(i)S(j)+S(j)^2)+b(S(i)-S(j))+c\}\\ \ \ \ \ \ \ \ \ \ \ =g(S(i))+\max\limits_{j<i}\{(-2aS(j))S(i)+(f(j)+aS(j)^2-bS(j))\}$$

然後我們就發現斜率優化已經成形了！

* $$A(j)=-2aS(j)$$
* $$B(j)=f(j)+aS(j)^2-bS(j)$$
* $$X(i)=S(i)$$
* $$h(i)=g(S(i))$$

那麼我們就可以套李超線段樹輕鬆解決這題了！但這題還可以做得更好！

* 斜率單調：$$S(j)$$遞增\(因為$$x_i$$都是正整數\)，而且 $$a<0$$。
* 查詢單調：$$S(i)$$遞增

所以我們就可以套單調隊列優化來解掉這題了。

